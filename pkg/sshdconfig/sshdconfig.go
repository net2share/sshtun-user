// Package sshdconfig provides functions for configuring sshd for tunnel users.
package sshdconfig

import (
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

// Configuration file paths.
const (
	MainConfig         = "/etc/ssh/sshd_config"
	DropInDir          = "/etc/ssh/sshd_config.d"
	BaseConfig         = "/etc/ssh/sshd_config.d/99-tunnel-base.conf"
	PasswordAuthConfig = "/etc/ssh/sshd_config.d/99-tunnel-password.conf"
	KeyAuthConfig      = "/etc/ssh/sshd_config.d/99-tunnel-key.conf"
)

// baseConfigContent contains the base hardening configuration.
const baseConfigContent = `# Hardened SSH config for tunnel server
# Generated by sshtun-user

# === Connection Handling ===
TCPKeepAlive no
ClientAliveInterval 30
ClientAliveCountMax 3
LoginGraceTime 15
MaxAuthTries 3
MaxSessions 10
# Rate limit: accept 50 freely, then drop 30% randomly, hard cap at 100
MaxStartups 50:30:100

# === Crypto Hardening ===
KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes128-ctr
MACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com

# === General Hardening ===
PermitEmptyPasswords no
UseDNS no
X11Forwarding no
PrintMotd no
PrintLastLog no
Compression yes
# Prevent QoS-based traffic fingerprinting
IPQoS cs0 cs0

# === Global Forwarding Defaults ===
AllowAgentForwarding no
AllowStreamLocalForwarding no
PermitTunnel no
# Prevent users from binding forwarded ports to 0.0.0.0
GatewayPorts no

# === Logging (important for shared credentials scenarios) ===
LogLevel VERBOSE
`

// passwordAuthConfigContent contains the password auth group configuration.
const passwordAuthConfigContent = `# Password-based tunnel user restrictions
# Generated by sshtun-user

Match Group sshtunnel-password
    # Allow password auth for these tunnel users
    PasswordAuthentication yes
    PubkeyAuthentication no
    # Only allow -L (local) and -D (SOCKS), block -R (remote)
    AllowTcpForwarding local
    # No interactive terminal
    PermitTTY no
    # Kill any command execution attempt (tunnels still work with ssh -N)
    ForceCommand /usr/sbin/nologin
    # Limit concurrent sessions per user
    MaxSessions 3
`

// keyAuthConfigContent contains the key auth group configuration.
const keyAuthConfigContent = `# Key-based tunnel user restrictions
# Generated by sshtun-user

Match Group sshtunnel-key
    # Key-only authentication
    PasswordAuthentication no
    PubkeyAuthentication yes
    # Only allow -L (local) and -D (SOCKS), block -R (remote)
    AllowTcpForwarding local
    # No interactive terminal
    PermitTTY no
    # Kill any command execution attempt (tunnels still work with ssh -N)
    ForceCommand /usr/sbin/nologin
    # Limit concurrent sessions per user
    MaxSessions 3
`

// EnsureIncludeDirective ensures the Include directive is present in sshd_config.
func EnsureIncludeDirective() error {
	data, err := os.ReadFile(MainConfig)
	if err != nil {
		return fmt.Errorf("failed to read sshd_config: %w", err)
	}

	// Check if Include directive for sshd_config.d is present
	pattern := regexp.MustCompile(`(?m)^Include.*/etc/ssh/sshd_config\.d/`)
	if pattern.Match(data) {
		return nil // Already present
	}

	fmt.Println("Warning: sshd_config.d not included in sshd_config")
	fmt.Println("Adding Include directive...")

	// Prepend Include directive
	newContent := "Include /etc/ssh/sshd_config.d/*.conf\n" + string(data)
	if err := os.WriteFile(MainConfig, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("failed to update sshd_config: %w", err)
	}

	// Ensure drop-in directory exists
	if err := os.MkdirAll(DropInDir, 0755); err != nil {
		return fmt.Errorf("failed to create drop-in directory: %w", err)
	}

	return nil
}

// Configure writes all sshd configuration files.
func Configure() error {
	// Ensure Include directive is present
	if err := EnsureIncludeDirective(); err != nil {
		return err
	}

	// Ensure drop-in directory exists
	if err := os.MkdirAll(DropInDir, 0755); err != nil {
		return fmt.Errorf("failed to create drop-in directory: %w", err)
	}

	// Write configuration files
	configs := []struct {
		path    string
		content string
	}{
		{BaseConfig, baseConfigContent},
		{PasswordAuthConfig, passwordAuthConfigContent},
		{KeyAuthConfig, keyAuthConfigContent},
	}

	for _, cfg := range configs {
		if err := os.WriteFile(cfg.path, []byte(cfg.content), 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", cfg.path, err)
		}
	}

	// Validate configuration
	if err := Validate(); err != nil {
		// Remove configs on validation failure
		Remove()
		return err
	}

	// Reload sshd
	if err := Reload(); err != nil {
		fmt.Printf("Warning: failed to reload sshd: %v\n", err)
	}

	fmt.Println("sshd hardening applied:")
	fmt.Printf("  - Base config: %s\n", BaseConfig)
	fmt.Printf("  - Password auth: %s\n", PasswordAuthConfig)
	fmt.Printf("  - Key auth: %s\n", KeyAuthConfig)

	return nil
}

// AddAuthorizedKeysDirective adds the AuthorizedKeysFile directive to key auth config.
func AddAuthorizedKeysDirective() error {
	data, err := os.ReadFile(KeyAuthConfig)
	if err != nil {
		return err
	}

	if strings.Contains(string(data), "AuthorizedKeysFile.*authorized_keys.d") {
		return nil // Already present
	}

	// Add directive after Match Group line
	content := strings.Replace(
		string(data),
		"Match Group sshtunnel-key",
		"Match Group sshtunnel-key\n    AuthorizedKeysFile /etc/ssh/authorized_keys.d/%u",
		1,
	)

	if err := os.WriteFile(KeyAuthConfig, []byte(content), 0644); err != nil {
		return err
	}

	return Reload()
}

// EnsureHostKeys generates SSH host keys if they don't exist.
func EnsureHostKeys() error {
	keyTypes := []struct {
		keyType string
		path    string
	}{
		{"rsa", "/etc/ssh/ssh_host_rsa_key"},
		{"ecdsa", "/etc/ssh/ssh_host_ecdsa_key"},
		{"ed25519", "/etc/ssh/ssh_host_ed25519_key"},
	}

	for _, k := range keyTypes {
		if _, err := os.Stat(k.path); os.IsNotExist(err) {
			fmt.Printf("Generating %s host key...\n", k.keyType)
			cmd := exec.Command("ssh-keygen", "-t", k.keyType, "-f", k.path, "-N", "")
			if err := cmd.Run(); err != nil {
				return fmt.Errorf("failed to generate %s host key: %w", k.keyType, err)
			}
		}
	}
	return nil
}

// Validate runs sshd -t to validate the configuration.
func Validate() error {
	// Ensure host keys exist (sshd -t requires them)
	if err := EnsureHostKeys(); err != nil {
		return err
	}

	cmd := exec.Command("sshd", "-t", "-f", MainConfig)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("invalid sshd config: %s", string(output))
	}
	fmt.Println("sshd config valid, reloading...")
	return nil
}

// Reload reloads the sshd service.
func Reload() error {
	// Try to find the correct service name
	services := []string{"sshd", "ssh", "openssh-server"}

	for _, svc := range services {
		// Check if service unit exists (is-enabled returns 0 for enabled, 1 for disabled, but both mean it exists)
		err := exec.Command("systemctl", "cat", svc).Run()
		if err != nil {
			continue // Service doesn't exist, try next
		}

		// Service exists, check if it's active
		if exec.Command("systemctl", "is-active", "--quiet", svc).Run() == nil {
			// Service is active, reload it
			if err := exec.Command("systemctl", "reload", svc).Run(); err != nil {
				// Reload failed, try restart
				if err := exec.Command("systemctl", "restart", svc).Run(); err != nil {
					return fmt.Errorf("failed to reload/restart %s: %w", svc, err)
				}
			}
			return nil
		}

		// Service exists but not active, try to start it
		if err := exec.Command("systemctl", "start", svc).Run(); err != nil {
			return fmt.Errorf("failed to start %s: %w", svc, err)
		}
		return nil
	}

	return fmt.Errorf("could not find SSH service (tried: sshd, ssh, openssh-server)")
}

// Remove removes all sshd configuration files created by this tool.
func Remove() error {
	files := []string{BaseConfig, PasswordAuthConfig, KeyAuthConfig}
	for _, f := range files {
		os.Remove(f)
	}
	return nil
}

// RemoveAndReload removes all sshd configuration files and reloads sshd.
func RemoveAndReload() error {
	if err := Remove(); err != nil {
		return err
	}

	// Reload sshd to apply changes
	if err := Reload(); err != nil {
		return fmt.Errorf("config files removed but failed to reload sshd: %w", err)
	}

	return nil
}

// IsConfigured checks if sshd hardening has been applied.
func IsConfigured() bool {
	_, err := os.Stat(BaseConfig)
	return err == nil
}
